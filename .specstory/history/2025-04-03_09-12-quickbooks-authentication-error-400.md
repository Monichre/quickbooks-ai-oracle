<!-- Generated by SpecStory -->

# QuickBooks Authentication Error 400 (2025-04-03 04:12:24)

_**User**_

code: 'ERR_BAD_REQUEST',
  config: [Object],
  request: [ClientRequest],
  response: [Object],
  status: 400,
  error: 'Request failed with status code 400',
  authResponse: [AuthResponse],
  intuit_tid: '',
  originalMessage: 'Request failed with status code 400',
  error_description: '',
  constructor: [Function],
  toJSON: [Function: toJSON]
}
ðŸš€ ~ tokens: null
 â¨¯ Error: Not authenticated with QuickBooks
    at quickbooksRequest (src/services/intuit/api.ts:59:8)
    at async DashboardPage (src/app/dashboard/page.tsx:44:43)
  57 |
  58 | 	if (!tokens) {
> 59 | 		throw new Error("Not authenticated with QuickBooks");
    ---
src/services/intuit/auth.ts (87:28) @ async refreshTokensIfNeeded


  85 | 	if (tokensNeedRefresh(tokens)) {
  86 | 		try {
> 87 | 			const refreshResponse = await oauthClient.refreshUsingToken(
     | 			                        ^
  88 | 				tokens.refresh_token,
  89 | 			);
  90 | 			const newTokens = refreshResponse.getJson();
  60 | 	}
  61 |

---

_**Assistant**_



---

The error shows a token refresh failure while trying to authenticate with QuickBooks. The problem occurs when calling `oauthClient.refreshUsingToken(tokens.refresh_token)` which returns a 400 Bad Request error.

Let's fix the token refresh functionality in the auth service:

---

```diff
  	if (tokensNeedRefresh(tokens)) {
  		try {
+ 			// Set the token in the client first
+ 			oauthClient.setToken({
+ 				access_token: tokens.access_token,
+ 				refresh_token: tokens.refresh_token,
+ 				token_type: tokens.token_type,
+ 				expires_in: tokens.expires_in,
+ 				x_refresh_token_expires_in: tokens.x_refresh_token_expires_in,
+ 				createdAt: tokens.createdAt,
+ 			});
+ 
+ 			// Try using the standard refresh method first
+ 			let newTokens;
+ 			try {
+ 				const refreshResponse = await oauthClient.refresh();
+ 				newTokens = refreshResponse.getJson();
+ 			} catch (refreshError) {
+ 				// If standard refresh fails, try the refreshUsingToken method
+ 				console.log("Standard refresh failed, trying refreshUsingToken");
  				const refreshResponse = await oauthClient.refreshUsingToken(
  					tokens.refresh_token,
  				);
- 			const newTokens = refreshResponse.getJson();
+ 				newTokens = refreshResponse.getJson();
+ 			}
+ 
  			await storeTokens(newTokens);
  			return newTokens;
  		} catch (error) {
  			console.error("Error refreshing tokens:", error);
+ 
+ 			// If we get a 400 error, the refresh token may be expired
+ 			// We should clear the tokens and redirect to re-authenticate
+ 			if (error.status === 400) {
+ 				console.log("Refresh token might be expired, clearing tokens");
+ 				await clearTokens();
+ 			}
+ 
  			return null;
  		}
  	}
  	return tokens;
  }
- // const refreshTokens = async () => {
- // 	const tokensNeedRefresh = oauthClient.isAccessTokenValid();
- // 	// const tokens = await getTokens();
- // 	// if (!tokens) return null;
- 
- // 	if (tokensNeedRefresh) {
- // 		try {
- // 			const refreshResponse = await oauthClient.refresh().then(authResponse => authResponse.getToken())
- // 			// const newTokens = refreshResponse.getJson();
- // 			// await storeTokens(newTokens);
- // 			// return newTokens;
- // 		} catch (error) {
- // 			console.error("Error refreshing tokens:", error);
- // 			return null;
- // 		}
- // 	}
- // 	return tokens;
- // // }
- // }
- // Revoke tokens and remove them from Clerk user metadata
- export async function revokeTokens(): Promise<boolean> {
- 	const tokens = await getTokens();
- 	if (!tokens) return false;
- 
- 	try {
- 		await oauthClient.revoke({ token: tokens.access_token });
- 
+ 
+ // Clear tokens from Clerk user metadata without revoking them
+ async function clearTokens(): Promise<boolean> {
  	const { userId } = await auth();
  	if (!userId) return false;
  
+ 	try {
  		// Use clerkClient pattern from docs
  		const client = await clerkClient();
```

```diff
  			},
  		});
- 
  		return true;
+ 	} catch (error) {
+ 		console.error("Error clearing tokens:", error);
+ 		return false;
+ 	}
+ }
+ 
+ // Revoke tokens and remove them from Clerk user metadata
+ export async function revokeTokens(): Promise<boolean> {
+ 	const tokens = await getTokens();
+ 	if (!tokens) return false;
+ 
+ 	try {
+ 		await oauthClient.revoke({ token: tokens.access_token });
+ 
+ 		// Clear the tokens from metadata
+ 		return await clearTokens();
  	} catch (error) {
  		console.error("Error revoking tokens:", error);
```

---

Now let's fix the linter error by properly typing the refresh response:

---

```diff
  
  			// Try using the standard refresh method first
- 			let newTokens;
+ 			let newTokens: IntuitTokens;
  			try {
- 				const refreshResponse = await oauthClient.refresh();
+ 				const refreshResponse: {
+ 					getJson(): IntuitTokens;
+ 				} = await oauthClient.refresh();
  				newTokens = refreshResponse.getJson();
  			} catch (refreshError) {
  				// If standard refresh fails, try the refreshUsingToken method
  				console.log("Standard refresh failed, trying refreshUsingToken");
- 				const refreshResponse = await oauthClient.refreshUsingToken(
- 					tokens.refresh_token,
- 				);
+ 				const refreshResponse: {
+ 					getJson(): IntuitTokens;
+ 				} = await oauthClient.refreshUsingToken(tokens.refresh_token);
  				newTokens = refreshResponse.getJson();
  			}
```

---

Now we need to check if the Intuit OAuth client is properly set up. Let's check the client file to ensure it's correctly configured:

---

<details>
            <summary>Searched codebase "intuit/client" â€¢ **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: /Users/liamellis/Desktop/quickbooks-oracle-initial/src/services/intuit/client.ts

---

Now let's check the API file to see how the QuickBooks API requests are made:

---

<details>
            <summary>Searched codebase "intuit/api" â€¢ **10** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

Read file: /Users/liamellis/Desktop/quickbooks-oracle-initial/src/services/intuit/api.ts

---

Let's also check the dashboard page where the error is occurring:

---

Read file: src/app/dashboard/page.tsx

---

Based on the code review, I'll create a more robust implementation to handle Intuit OAuth token refresh properly. Let me update the solution:

---

```diff
  import {getCompanyInfo} from '@/services/intuit/api'
  import {Card} from '@/components/ui/card'
- import {refreshTokensIfNeeded, isAuthenticated} from '@/services/intuit/auth'
+ import {
+   refreshTokensIfNeeded,
+   isAuthenticated,
+   getAuthorizationUrl,
+ } from '@/services/intuit/auth'
  
  import {Alert, AlertDescription, AlertTitle} from '@/components/ui/alert'
```

```diff
  export default async function DashboardPage() {
    // Check if authenticated with QuickBooks
-   const authenticated = await isAuthenticated()
+   let authenticated = false
+   let authError = null
+   let authUrl = ''
+ 
+   try {
+     authenticated = await isAuthenticated()
+     if (!authenticated) {
+       authUrl = await getAuthorizationUrl()
+     }
+   } catch (error) {
+     console.error('Authentication check error:', error)
+     authError = error instanceof Error ? error.message : 'Authentication error'
+     try {
+       authUrl = await getAuthorizationUrl()
+     } catch (urlError) {
+       console.error('Failed to get auth URL:', urlError)
+     }
+   }
  
    console.log('ðŸš€ ~ DashboardPage ~ authenticated:', authenticated)
  
-   // Redirect to QuickBooks connection page if not authenticated
-   // if (!authenticated) {
-   //   await refreshTokensIfNeeded()
-   //   // redirect('/quickbooks')
-   // }
- 
-   // try {
-   // Ensure we have valid tokens before loading company data
-   // await refreshTokensIfNeeded()
-   // Load company data directly from the API
-   const companyData: any = authenticated ? await getCompanyInfo() : null
- 
+   // If authenticated, try to load company data
+   let companyData = null
+   let dataError = null
+ 
+   if (authenticated) {
+     try {
+       companyData = await getCompanyInfo()
        console.log('ðŸš€ ~ DashboardPage ~ companyData:', companyData)
- 
+     } catch (error) {
+       console.error('Company data error:', error)
+       dataError = error instanceof Error ? error.message : 'Data loading error'
+     }
+   }
+ 
+   // If we have authentication or data errors, show error UI
+   if (!authenticated || authError || dataError) {
+     return (
+       <div className='container mx-auto p-6'>
+         {(authError || dataError) && (
+           <Alert variant='destructive' className='mb-6'>
+             <AlertTitle>
+               {authError
+                 ? 'QuickBooks Authentication Error'
+                 : 'Data Loading Error'}
+             </AlertTitle>
+             <AlertDescription>{authError || dataError}</AlertDescription>
+           </Alert>
+         )}
+ 
+         {!authenticated && !authError && (
+           <Alert className='mb-6'>
+             <AlertTitle>QuickBooks Connection Required</AlertTitle>
+             <AlertDescription>
+               Please connect your QuickBooks account to continue.
+             </AlertDescription>
+           </Alert>
+         )}
+ 
+         <div className='flex gap-4 mt-6'>
+           {authUrl ? (
+             <Link href={authUrl}>
+               <Button variant='default'>Connect QuickBooks</Button>
+             </Link>
+           ) : (
+             <Link href='/quickbooks'>
+               <Button variant='default'>Go to QuickBooks Setup</Button>
+             </Link>
+           )}
+           <Link href='/'>
+             <Button variant='outline'>Go Home</Button>
+           </Link>
+         </div>
+       </div>
+     )
+   }
+ 
+   // Success case - show dashboard content
    return (
      <div className='flex flex-col'>
```

---

Now let's fix the intuit/client.ts file to ensure it's correctly initializing the OAuth client with the proper types:

---

```diff
- const OAuthClient = require("intuit-oauth");
+ import OAuthClient from "intuit-oauth";
  
- export const oauthClient: any = new OAuthClient({
+ export const oauthClient = new OAuthClient({
  	clientId: process.env.INTUIT_CLIENT_ID,
  	clientSecret: process.env.INTUIT_CLIENT_SECRET,
```

---

Now let's fix the linter error related to the logging property in the client configuration:

---

```diff
  	environment: process.env.INTUIT_ENVIRONMENT_ID,
  	redirectUri: process.env.INTUIT_REDIRECT_URI,
- 	logging: true,
  });
  
```

---

The changes we've made should resolve the QuickBooks authentication and token refresh issues. Here's a summary of what we did:

1. Updated the token refresh mechanism in `auth.ts`:
   - Added proper type definitions for API responses
   - Implemented a more robust refresh process using both standard refresh method and refreshUsingToken
   - Added fallback mechanisms and better error handling
   - Added a clearTokens function to handle expired tokens

2. Improved the `client.ts` file:
   - Switched from CommonJS to ESM imports
   - Used proper TypeScript typing instead of `any`
   - Removed the unsupported `logging` property from the configuration

3. Enhanced the `dashboard/page.tsx`:
   - Added comprehensive error handling for authentication and data loading 
   - Added a user-friendly authentication flow with proper UI for error cases
   - Implemented direct QuickBooks connection link when not authenticated

These changes should resolve the 400 Bad Request error when refreshing tokens and provide a better user experience when authentication issues occur.

---

_**User**_

how long are tokens typically good for?

---

_**Assistant**_



---

Based on the Intuit OAuth implementation:

- Access tokens typically expire after 1 hour (3600 seconds)
- Refresh tokens are usually valid for 100-101 days (8,640,000 to 8,726,400 seconds)

The code automatically refreshes tokens 15 minutes before they expire, as seen in the `tokensNeedRefresh` function:

```typescript
const expiryTime = tokens.createdAt + tokens.expires_in * 1000;
const refreshWindow = 15 * 60 * 1000; // 15 minutes
```

The `expires_in` and `x_refresh_token_expires_in` values are returned directly from the Intuit API when tokens are created or refreshed.

---

