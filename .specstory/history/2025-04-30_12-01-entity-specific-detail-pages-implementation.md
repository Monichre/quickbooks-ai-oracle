<!-- Generated by SpecStory -->

# Entity Specific Detail Pages Implementation (2025-04-30 07:01:45)

_**User**_

I want to begin implementing Entity Specific Detail pages by flushing out the @page.tsx. Would it be best to manually begin creating nested entity routes explicitly or continue to handle the rendering of entity specific data dynamically? If done dynamically we could implement similar logic as @entityApiFunctionMap and @fetchEntityData in  @helpers.ts but modify for getEntityById. What do you think is best?

---

_**Assistant**_



---

Based on your codebase, continuing with the dynamic approach would be most consistent with your existing architecture. Here's how I recommend implementing entity-specific detail pages:

1. Create a new mapping for entity detail functions in `helpers.ts`:

```typescript
export type GetEntityByIdFunction = (id: string, params?: Record<string, unknown>) => Promise<unknown>;

export const entityDetailApiFunctionMap: Record<EntityType, GetEntityByIdFunction> = {
  accounts: getAccountById,
  customers: getCustomerById,
  vendors: getVendorById,
  // Add all other entity types...
};
```

2. Add a `fetchEntityById` helper function:

```typescript
export async function fetchEntityById(entity: string, id: string, params?: Record<string, unknown>) {
  if (!entity || !entityDetailApiFunctionMap[entity as EntityType]) {
    return notFound();
  }

  try {
    const data = await entityDetailApiFunctionMap[entity as EntityType](id, params);
    
    // Similar transformation logic as fetchEntityData
    const capitalizedEntity = entity
      .replace(/-([a-z])/g, (g) => g[1].toUpperCase())
      .replace(/s$/, "")
      .replace(/^[a-z]/, (c) => c.toUpperCase());
    
    if (data.QueryResponse && Object.prototype.hasOwnProperty.call(data.QueryResponse, capitalizedEntity)) {
      return data.QueryResponse[capitalizedEntity];
    }
    
    return data.QueryResponse || data;
  } catch (error) {
    console.error(`Error fetching ${entity} detail for ID ${id}:`, error);
    throw new Error(`Failed to fetch ${entity} detail: ${(error as Error).message}`);
  }
}
```

3. Update your detail page to use this function:

```typescript
export default async function EntityDetailPage({
  params,
}: {
  params: {entity: string; id: string}
}) {
  const {entity, id} = params;
  const entityData = await fetchEntityById(entity, id);
  
  return (
    <div>
      <h1>{entityData.name || `${entity} Details`}</h1>
      {/* Render common fields here */}
      
      {/* Conditionally render entity-specific fields */}
      {entity === 'customers' && (
        <CustomerDetailFields data={entityData} />
      )}
      {/* Add conditionals for other entity types */}
    </div>
  );
}
```

This approach gives you:
1. Consistent pattern with your existing code
2. Central place to handle API errors and response formatting
3. Flexibility to add entity-specific rendering while maintaining shared logic
4. Easy extension for new entity types

For very complex entity pages with significantly different layouts, you could add entity-specific components but still use the dynamic API fetching approach.

---

_**User**_

Ok good thinking. Go ahead and begin implementing this solution

---

_**Assistant**_



---

Let me implement the dynamic entity detail page solution:

---

```diff
  import type { EntityType } from "@/services/intuit/types";
  import { notFound } from "next/navigation";
+ 
  export type ApiFunction = (params?: {
  	limit?: number;
- 	[key: string]: any;
- }) => Promise<any>;
+ 	[key: string]: unknown;
+ }) => Promise<unknown>;
  
  export const entityApiFunctionMap: Record<EntityType, ApiFunction> = {
```

```diff
  	"profit-and-loss": getProfitAndLossReport,
  };
+ 
+ // Type for entity detail API functions
+ export type GetEntityByIdFunction = (
+ 	id: string,
+ 	params?: Record<string, unknown>,
+ ) => Promise<unknown>;
+ 
+ // Map entity types to their respective "get by ID" functions
+ export const entityDetailApiFunctionMap: Record<
+ 	EntityType,
+ 	GetEntityByIdFunction
+ > = {
+ 	accounts: (id, params) => findAccounts({ ...params, id }),
+ 	customers: (id, params) => findCustomers({ ...params, id }),
+ 	vendors: (id, params) => findVendors({ ...params, id }),
+ 	invoices: (id, params) => findInvoices({ ...params, id }),
+ 	items: (id, params) => findItems({ ...params, id }),
+ 	products: (id, params) => findProducts({ ...params, id }),
+ 	purchases: (id, params) => findPurchases({ ...params, id }),
+ 	"purchase-orders": (id, params) => findPurchaseOrders({ ...params, id }),
+ 	estimates: (id, params) => findEstimates({ ...params, id }),
+ 	payments: (id, params) => findPayments({ ...params, id }),
+ 	employees: (id, params) => findEmployees({ ...params, id }),
+ 	bills: (id, params) => findBills({ ...params, id }),
+ 	"account-list-detail": (id, params) =>
+ 		getAccountListDetail({ ...params, id }),
+ 	"profit-and-loss": (id, params) => getProfitAndLossReport({ ...params, id }),
+ };
  
  // Server Component to handle data fetching
- export async function fetchEntityData(entity: string, searchParams?) {
+ export async function fetchEntityData(
+ 	entity: string,
+ 	searchParams?: Record<string, unknown>,
+ ) {
  	if (!entity || !entityApiFunctionMap[entity as EntityType]) {
  		return notFound();
```

```diff
  	try {
  		// Call the appropriate API function with default parameters
- 		const response: any = await entityApiFunctionMap[entity as EntityType]({
+ 		const response = await entityApiFunctionMap[entity as EntityType]({
  			limit: 100,
  			...(searchParams || {}),
```

```diff
  	}
  }
+ 
+ // Helper function to fetch entity data by ID
+ export async function fetchEntityById(
+ 	entity: string,
+ 	id: string,
+ 	params?: Record<string, unknown>,
+ ) {
+ 	if (!entity || !entityDetailApiFunctionMap[entity as EntityType]) {
+ 		return notFound();
+ 	}
+ 
+ 	try {
+ 		// Call the appropriate entity detail API function
+ 		const response = await entityDetailApiFunctionMap[entity as EntityType](
+ 			id,
+ 			params,
+ 		);
+ 
+ 		// Convert entity string to capitalized singular form for accessing QueryResponse
+ 		const capitalizedEntity = entity
+ 			.replace(/-([a-z])/g, (g) => g[1].toUpperCase())
+ 			.replace(/s$/, "")
+ 			.replace(/^[a-z]/, (c) => c.toUpperCase());
+ 
+ 		// Handle QueryResponse pattern similar to fetchEntityData
+ 		if (
+ 			response.QueryResponse &&
+ 			Object.prototype.hasOwnProperty.call(
+ 				response.QueryResponse,
+ 				capitalizedEntity,
+ 			)
+ 		) {
+ 			// For a single entity, we expect an array with one item
+ 			const data = response.QueryResponse[capitalizedEntity];
+ 			// If it's an array with one item, return that item
+ 			if (Array.isArray(data) && data.length === 1) {
+ 				return data[0];
+ 			}
+ 			// Otherwise return the entire data
+ 			return data;
+ 		}
+ 
+ 		// Fallback to the entire QueryResponse or response if specific key not found
+ 		return response.QueryResponse || response;
+ 	} catch (error) {
+ 		console.error(`Error fetching ${entity} detail for ID ${id}:`, error);
+ 		throw new Error(
+ 			`Failed to fetch ${entity} detail: ${(error as Error).message}`,
+ 		);
+ 	}
+ }
  
```

---

Now I'll update the entity detail page to use our new helper function:

---

```diff
+ import {fetchEntityById} from '@/services/intuit/_common/helpers'
+ import {
+   Card,
+   CardContent,
+   CardDescription,
+   CardHeader,
+   CardTitle,
+ } from '@/components/ui/card'
+ import {Skeleton} from '@/components/ui/skeleton'
+ import {Suspense} from 'react'
+ import {notFound} from 'next/navigation'
+ 
+ // Loading state component
+ function EntityDetailLoading() {
+   return (
+     <div className='space-y-4'>
+       <Skeleton className='h-10 w-3/4' />
+       <Card>
+         <CardHeader>
+           <Skeleton className='h-6 w-1/3' />
+         </CardHeader>
+         <CardContent className='space-y-4'>
+           <Skeleton className='h-4 w-full' />
+           <Skeleton className='h-4 w-full' />
+           <Skeleton className='h-4 w-3/4' />
+         </CardContent>
+       </Card>
+     </div>
+   )
+ }
+ 
+ // Generic field display component
+ function EntityField({
+   label,
+   value,
+ }: {
+   label: string
+   value: string | number | null | undefined
+ }) {
+   if (value === undefined || value === null) return null
+ 
+   return (
+     <div className='py-2'>
+       <div className='text-sm font-medium text-gray-500'>{label}</div>
+       <div className='mt-1'>{value}</div>
+     </div>
+   )
+ }
+ 
+ // Entity-specific detail components
+ function CustomerDetail({data}: {data: any}) {
+   return (
+     <>
+       <EntityField label='Company Name' value={data.CompanyName} />
+       <EntityField label='Display Name' value={data.DisplayName} />
+       <EntityField label='Email' value={data.PrimaryEmailAddr?.Address} />
+       <EntityField label='Phone' value={data.PrimaryPhone?.FreeFormNumber} />
+       <EntityField label='Balance' value={data.Balance} />
+     </>
+   )
+ }
+ 
+ function VendorDetail({data}: {data: any}) {
+   return (
+     <>
+       <EntityField label='Company Name' value={data.CompanyName} />
+       <EntityField label='Display Name' value={data.DisplayName} />
+       <EntityField label='Email' value={data.PrimaryEmailAddr?.Address} />
+       <EntityField label='Phone' value={data.PrimaryPhone?.FreeFormNumber} />
+       <EntityField label='Balance' value={data.Balance} />
+     </>
+   )
+ }
+ 
+ function InvoiceDetail({data}: {data: any}) {
+   return (
+     <>
+       <EntityField label='Invoice Number' value={data.DocNumber} />
+       <EntityField label='Customer' value={data.CustomerRef?.name} />
+       <EntityField label='Total Amount' value={data.TotalAmt} />
+       <EntityField label='Balance' value={data.Balance} />
+       <EntityField label='Due Date' value={data.DueDate} />
+     </>
+   )
+ }
+ 
+ // Default entity detail component
+ function GenericEntityDetail({data, entity}: {data: any; entity: string}) {
+   return (
+     <div className='space-y-4'>
+       {Object.entries(data).map(([key, value]) => {
+         // Skip rendering complex nested objects or arrays
+         if (typeof value === 'object' && value !== null) return null
+ 
+         return (
+           <EntityField key={key} label={key} value={value as string | number} />
+         )
+       })}
+     </div>
+   )
+ }
+ 
+ // Main entity detail component with conditional rendering
+ function EntityDetailContent({entity, data}: {entity: string; data: any}) {
+   // Function to get the entity title
+   const getEntityTitle = () => {
+     if (!data) return `${entity} Details`
+ 
+     // Try to find a name field based on common patterns
+     const nameField =
+       data.DisplayName || data.Name || data.DocNumber || data.Id || 'Details'
+     return `${
+       entity.charAt(0).toUpperCase() + entity.slice(1).replace(/-/g, ' ')
+     } - ${nameField}`
+   }
+ 
+   return (
+     <Card className='w-full'>
+       <CardHeader>
+         <CardTitle>{getEntityTitle()}</CardTitle>
+         <CardDescription>ID: {data?.Id || 'N/A'}</CardDescription>
+       </CardHeader>
+       <CardContent>
+         <div className='divide-y'>
+           {/* Render appropriate detail component based on entity type */}
+           {entity === 'customers' && <CustomerDetail data={data} />}
+           {entity === 'vendors' && <VendorDetail data={data} />}
+           {entity === 'invoices' && <InvoiceDetail data={data} />}
+           {/* For entities without specific components, use generic renderer */}
+           {entity !== 'customers' &&
+             entity !== 'vendors' &&
+             entity !== 'invoices' && (
+               <GenericEntityDetail data={data} entity={entity} />
+             )}
+         </div>
+       </CardContent>
+     </Card>
+   )
+ }
+ 
+ // Async wrapper for data fetching
+ async function EntityDetailWithData({
+   entity,
+   id,
+ }: {
+   entity: string
+   id: string
+ }) {
+   const entityData = await fetchEntityById(entity, id)
+ 
+   if (!entityData) {
+     return notFound()
+   }
+ 
+   return <EntityDetailContent entity={entity} data={entityData} />
+ }
+ 
+ // Main page component
  export default async function EntityDetailPage({
    params,
  }: {
    params: {entity: string; id: string}
  }) {
-   const {entity, id} = await params
+   const {entity, id} = params
+ 
    return (
-     <div>
-       EntityDetailPage: entity: {entity}, id: {id}
+     <div className='container mx-auto py-6 space-y-6'>
+       <h1 className='text-2xl font-bold'>
+         {entity.charAt(0).toUpperCase() + entity.slice(1).replace(/-/g, ' ')}{' '}
+         Details
+       </h1>
+ 
+       <Suspense fallback={<EntityDetailLoading />}>
+         <EntityDetailWithData entity={entity} id={id} />
+       </Suspense>
      </div>
    )
```

---

Now we need to create entity-specific type interfaces to improve type safety:

---

```diff
- 
+ // Current entity types
+ export type EntityType =
+ 	| "accounts"
+ 	| "customers"
+ 	| "vendors"
+ 	| "invoices"
+ 	| "items"
+ 	| "products"
+ 	| "purchases"
+ 	| "purchase-orders"
+ 	| "estimates"
+ 	| "payments"
+ 	| "employees"
+ 	| "bills"
+ 	| "account-list-detail"
+ 	| "profit-and-loss";
+ 
+ // Common interfaces
+ 
+ export interface ReferenceType {
+ 	name: string;
+ 	value: string;
+ }
+ 
+ export interface Address {
+ 	Id?: string;
+ 	Line1?: string;
+ 	Line2?: string;
+ 	City?: string;
+ 	CountrySubDivisionCode?: string;
+ 	Country?: string;
+ 	PostalCode?: string;
+ }
+ 
+ export interface EmailAddress {
+ 	Address?: string;
+ }
+ 
+ export interface PhoneNumber {
+ 	FreeFormNumber?: string;
+ }
+ 
+ // Entity-specific interfaces
+ 
+ export interface Customer {
+ 	Id: string;
+ 	DisplayName?: string;
+ 	CompanyName?: string;
+ 	PrimaryEmailAddr?: EmailAddress;
+ 	PrimaryPhone?: PhoneNumber;
+ 	BillAddr?: Address;
+ 	ShipAddr?: Address;
+ 	Balance?: number;
+ 	Active?: boolean;
+ 	Notes?: string;
+ 	WebAddr?: { URI?: string };
+ 	Taxable?: boolean;
+ }
+ 
+ export interface Vendor {
+ 	Id: string;
+ 	DisplayName?: string;
+ 	CompanyName?: string;
+ 	PrimaryEmailAddr?: EmailAddress;
+ 	PrimaryPhone?: PhoneNumber;
+ 	BillAddr?: Address;
+ 	Balance?: number;
+ 	Active?: boolean;
+ 	Notes?: string;
+ 	WebAddr?: { URI?: string };
+ 	TaxIdentifier?: string;
+ }
+ 
+ export interface Invoice {
+ 	Id: string;
+ 	DocNumber?: string;
+ 	CustomerRef?: ReferenceType;
+ 	TxnDate?: string;
+ 	DueDate?: string;
+ 	TotalAmt?: number;
+ 	Balance?: number;
+ 	Line?: Array<{
+ 		Id?: string;
+ 		LineNum?: number;
+ 		Description?: string;
+ 		Amount?: number;
+ 		SalesItemLineDetail?: {
+ 			ItemRef?: ReferenceType;
+ 			Qty?: number;
+ 			UnitPrice?: number;
+ 		};
+ 	}>;
+ }
+ 
+ export interface PurchaseOrder {
+ 	Id: string;
+ 	DocNumber?: string;
+ 	VendorRef?: ReferenceType;
+ 	APAccountRef?: ReferenceType;
+ 	TotalAmt?: number;
+ 	Line?: Array<{
+ 		Id?: string;
+ 		LineNum?: number;
+ 		Description?: string;
+ 		Amount?: number;
+ 		ItemBasedExpenseLineDetail?: {
+ 			ItemRef?: ReferenceType;
+ 			Qty?: number;
+ 			UnitPrice?: number;
+ 		};
+ 	}>;
+ }
+ 
+ export interface Account {
+ 	Id: string;
+ 	Name?: string;
+ 	AccountType?: string;
+ 	AccountSubType?: string;
+ 	CurrentBalance?: number;
+ 	Active?: boolean;
+ 	Description?: string;
+ }
+ 
+ export interface Estimate {
+ 	Id: string;
+ 	DocNumber?: string;
+ 	CustomerRef?: ReferenceType;
+ 	TxnDate?: string;
+ 	DueDate?: string;
+ 	TotalAmt?: number;
+ 	Line?: Array<{
+ 		Id?: string;
+ 		LineNum?: number;
+ 		Description?: string;
+ 		Amount?: number;
+ 		SalesItemLineDetail?: {
+ 			ItemRef?: ReferenceType;
+ 			Qty?: number;
+ 			UnitPrice?: number;
+ 		};
+ 	}>;
+ }
+ 
+ // Type mapping for entity to interface
+ export type EntityTypeToInterface = {
+ 	customers: Customer;
+ 	vendors: Vendor;
+ 	invoices: Invoice;
+ 	"purchase-orders": PurchaseOrder;
+ 	accounts: Account;
+ 	estimates: Estimate;
+ 	// Add other entities as needed
+ 	[key: string]: any; // Fallback for unknown entities
+ };
+ 
```

---

Now let's update our detail page to use these types:

---

```diff
  import {Suspense} from 'react'
  import {notFound} from 'next/navigation'
+ import type {
+   Customer,
+   Vendor,
+   Invoice,
+   PurchaseOrder,
+   Account,
+   Estimate,
+   EntityTypeToInterface,
+   EntityType,
+ } from '@/services/intuit/types'
  
  // Loading state component
```

```diff
  
  // Entity-specific detail components
- function CustomerDetail({data}: {data: any}) {
+ function CustomerDetail({data}: {data: Customer}) {
    return (
      <>
```

```diff
        <EntityField label='Phone' value={data.PrimaryPhone?.FreeFormNumber} />
        <EntityField label='Balance' value={data.Balance} />
+       {data.BillAddr && (
+         <div className='py-2'>
+           <div className='text-sm font-medium text-gray-500'>
+             Billing Address
+           </div>
+           <div className='mt-1'>
+             {data.BillAddr.Line1 && <div>{data.BillAddr.Line1}</div>}
+             {data.BillAddr.Line2 && <div>{data.BillAddr.Line2}</div>}
+             {data.BillAddr.City && <span>{data.BillAddr.City}, </span>}
+             {data.BillAddr.CountrySubDivisionCode && (
+               <span>{data.BillAddr.CountrySubDivisionCode} </span>
+             )}
+             {data.BillAddr.PostalCode && (
+               <span>{data.BillAddr.PostalCode}</span>
+             )}
+           </div>
+         </div>
+       )}
      </>
    )
  }
  
- function VendorDetail({data}: {data: any}) {
+ function VendorDetail({data}: {data: Vendor}) {
    return (
      <>
```

```diff
        <EntityField label='Phone' value={data.PrimaryPhone?.FreeFormNumber} />
        <EntityField label='Balance' value={data.Balance} />
+       <EntityField label='Tax Identifier' value={data.TaxIdentifier} />
+       {data.BillAddr && (
+         <div className='py-2'>
+           <div className='text-sm font-medium text-gray-500'>Address</div>
+           <div className='mt-1'>
+             {data.BillAddr.Line1 && <div>{data.BillAddr.Line1}</div>}
+             {data.BillAddr.Line2 && <div>{data.BillAddr.Line2}</div>}
+             {data.BillAddr.City && <span>{data.BillAddr.City}, </span>}
+             {data.BillAddr.CountrySubDivisionCode && (
+               <span>{data.BillAddr.CountrySubDivisionCode} </span>
+             )}
+             {data.BillAddr.PostalCode && (
+               <span>{data.BillAddr.PostalCode}</span>
+             )}
+           </div>
+         </div>
+       )}
      </>
    )
  }
  
- function InvoiceDetail({data}: {data: any}) {
+ function InvoiceDetail({data}: {data: Invoice}) {
    return (
      <>
```

```diff
        <EntityField label='Balance' value={data.Balance} />
        <EntityField label='Due Date' value={data.DueDate} />
+       <EntityField label='Transaction Date' value={data.TxnDate} />
+ 
+       {data.Line && data.Line.length > 0 && (
+         <div className='py-2'>
+           <div className='text-sm font-medium text-gray-500 mb-2'>
+             Line Items
+           </div>
+           <div className='mt-1 border rounded-md overflow-hidden'>
+             <table className='min-w-full divide-y divide-gray-200'>
+               <thead className='bg-gray-50'>
+                 <tr>
+                   <th className='px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Description
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Qty
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Price
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Amount
+                   </th>
+                 </tr>
+               </thead>
+               <tbody className='bg-white divide-y divide-gray-200'>
+                 {data.Line.map((line, index) => (
+                   <tr key={line.Id || index}>
+                     <td className='px-4 py-2 text-sm text-gray-900'>
+                       {line.Description || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.SalesItemLineDetail?.Qty || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.SalesItemLineDetail?.UnitPrice || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.Amount || 'N/A'}
+                     </td>
+                   </tr>
+                 ))}
+               </tbody>
+             </table>
+           </div>
+         </div>
+       )}
+     </>
+   )
+ }
+ 
+ function PurchaseOrderDetail({data}: {data: PurchaseOrder}) {
+   return (
+     <>
+       <EntityField label='PO Number' value={data.DocNumber} />
+       <EntityField label='Vendor' value={data.VendorRef?.name} />
+       <EntityField label='Total Amount' value={data.TotalAmt} />
+ 
+       {data.Line && data.Line.length > 0 && (
+         <div className='py-2'>
+           <div className='text-sm font-medium text-gray-500 mb-2'>
+             Line Items
+           </div>
+           <div className='mt-1 border rounded-md overflow-hidden'>
+             <table className='min-w-full divide-y divide-gray-200'>
+               <thead className='bg-gray-50'>
+                 <tr>
+                   <th className='px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Description
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Qty
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Price
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Amount
+                   </th>
+                 </tr>
+               </thead>
+               <tbody className='bg-white divide-y divide-gray-200'>
+                 {data.Line.map((line, index) => (
+                   <tr key={line.Id || index}>
+                     <td className='px-4 py-2 text-sm text-gray-900'>
+                       {line.Description || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.ItemBasedExpenseLineDetail?.Qty || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.ItemBasedExpenseLineDetail?.UnitPrice || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.Amount || 'N/A'}
+                     </td>
+                   </tr>
+                 ))}
+               </tbody>
+             </table>
+           </div>
+         </div>
+       )}
+     </>
+   )
+ }
+ 
+ function AccountDetail({data}: {data: Account}) {
+   return (
+     <>
+       <EntityField label='Name' value={data.Name} />
+       <EntityField label='Account Type' value={data.AccountType} />
+       <EntityField label='Account Sub-Type' value={data.AccountSubType} />
+       <EntityField label='Current Balance' value={data.CurrentBalance} />
+       <EntityField label='Description' value={data.Description} />
+       <EntityField label='Active' value={data.Active ? 'Yes' : 'No'} />
+     </>
+   )
+ }
+ 
+ function EstimateDetail({data}: {data: Estimate}) {
+   return (
+     <>
+       <EntityField label='Estimate Number' value={data.DocNumber} />
+       <EntityField label='Customer' value={data.CustomerRef?.name} />
+       <EntityField label='Total Amount' value={data.TotalAmt} />
+       <EntityField label='Date' value={data.TxnDate} />
+       <EntityField label='Due Date' value={data.DueDate} />
+ 
+       {data.Line && data.Line.length > 0 && (
+         <div className='py-2'>
+           <div className='text-sm font-medium text-gray-500 mb-2'>
+             Line Items
+           </div>
+           <div className='mt-1 border rounded-md overflow-hidden'>
+             <table className='min-w-full divide-y divide-gray-200'>
+               <thead className='bg-gray-50'>
+                 <tr>
+                   <th className='px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Description
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Qty
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Price
+                   </th>
+                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
+                     Amount
+                   </th>
+                 </tr>
+               </thead>
+               <tbody className='bg-white divide-y divide-gray-200'>
+                 {data.Line.map((line, index) => (
+                   <tr key={line.Id || index}>
+                     <td className='px-4 py-2 text-sm text-gray-900'>
+                       {line.Description || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.SalesItemLineDetail?.Qty || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.SalesItemLineDetail?.UnitPrice || 'N/A'}
+                     </td>
+                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
+                       {line.Amount || 'N/A'}
+                     </td>
+                   </tr>
+                 ))}
+               </tbody>
+             </table>
+           </div>
+         </div>
+       )}
      </>
    )
  }
  
  // Default entity detail component
- function GenericEntityDetail({data, entity}: {data: any; entity: string}) {
+ function GenericEntityDetail({
+   data,
+   entity,
+ }: {
+   data: Record<string, unknown>
+   entity: string
+ }) {
    return (
      <div className='space-y-4'>
```

```diff
  
  // Main entity detail component with conditional rendering
- function EntityDetailContent({entity, data}: {entity: string; data: any}) {
+ function EntityDetailContent({
+   entity,
+   data,
+ }: {
+   entity: string
+   data: EntityTypeToInterface[keyof EntityTypeToInterface]
+ }) {
    // Function to get the entity title
    const getEntityTitle = () => {
```

```diff
      // Try to find a name field based on common patterns
      const nameField =
-       data.DisplayName || data.Name || data.DocNumber || data.Id || 'Details'
+       (data as any).DisplayName ||
+       (data as any).Name ||
+       (data as any).DocNumber ||
+       (data as any).Id ||
+       'Details'
      return `${
        entity.charAt(0).toUpperCase() + entity.slice(1).replace(/-/g, ' ')
```

```diff
        <CardHeader>
          <CardTitle>{getEntityTitle()}</CardTitle>
-         <CardDescription>ID: {data?.Id || 'N/A'}</CardDescription>
+         <CardDescription>ID: {(data as any)?.Id || 'N/A'}</CardDescription>
        </CardHeader>
        <CardContent>
          <div className='divide-y'>
            {/* Render appropriate detail component based on entity type */}
-           {entity === 'customers' && <CustomerDetail data={data} />}
-           {entity === 'vendors' && <VendorDetail data={data} />}
-           {entity === 'invoices' && <InvoiceDetail data={data} />}
+           {entity === 'customers' && <CustomerDetail data={data as Customer} />}
+           {entity === 'vendors' && <VendorDetail data={data as Vendor} />}
+           {entity === 'invoices' && <InvoiceDetail data={data as Invoice} />}
+           {entity === 'purchase-orders' && (
+             <PurchaseOrderDetail data={data as PurchaseOrder} />
+           )}
+           {entity === 'accounts' && <AccountDetail data={data as Account} />}
+           {entity === 'estimates' && <EstimateDetail data={data as Estimate} />}
+ 
            {/* For entities without specific components, use generic renderer */}
            {entity !== 'customers' &&
              entity !== 'vendors' &&
-             entity !== 'invoices' && (
-               <GenericEntityDetail data={data} entity={entity} />
+             entity !== 'invoices' &&
+             entity !== 'purchase-orders' &&
+             entity !== 'accounts' &&
+             entity !== 'estimates' && (
+               <GenericEntityDetail
+                 data={data as Record<string, unknown>}
+                 entity={entity}
+               />
              )}
          </div>
```

---

Now we need to update the API helper functions to include the entity detail implementations:

---

```diff
- 
+ import { getIntuitClient } from "@/services/intuit/_common/client";
+ 
+ // List/query API functions
+ export async function findAccounts(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Account ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findCustomers(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Customer ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findVendors(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Vendor ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findInvoices(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Invoice ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findItems(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Item ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findProducts(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Item WHERE Type = 'Inventory' OR Type = 'Service' ${params.id ? `AND Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findPurchases(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Purchase ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findPurchaseOrders(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM PurchaseOrder ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findEstimates(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Estimate ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findPayments(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Payment ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findEmployees(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Employee ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function findBills(params = {}) {
+ 	const client = await getIntuitClient();
+ 	return client.get("/query", {
+ 		params: {
+ 			query: `SELECT * FROM Bill ${params.id ? `WHERE Id = '${params.id}'` : ""} MAXRESULTS ${params.limit || 100}`,
+ 			...params,
+ 		},
+ 	});
+ }
+ 
+ export async function getAccountListDetail(params = {}) {
+ 	const client = await getIntuitClient();
+ 	// This is a placeholder implementation - you'll need to implement the specific query or endpoint
+ 	return client.get("/reports/AccountList", { params });
+ }
+ 
+ export async function getProfitAndLossReport(params = {}) {
+ 	const client = await getIntuitClient();
+ 	// This is a placeholder implementation - you'll need to implement the specific query or endpoint
+ 	return client.get("/reports/ProfitAndLoss", { params });
+ }
+ 
+ // Export additional API functions as needed
+ 
```

---

Let's create or update the Intuit client to support our API calls:

---

```diff
- 
+ import axios from "axios";
+ import { cookies } from "next/headers";
+ 
+ // Intuit API client interface
+ interface IntuitClient {
+ 	get: (path: string, config?: any) => Promise<any>;
+ 	post: (path: string, data?: any, config?: any) => Promise<any>;
+ 	put: (path: string, data?: any, config?: any) => Promise<any>;
+ 	delete: (path: string, config?: any) => Promise<any>;
+ }
+ 
+ // Get Intuit access token from cookies
+ export async function getIntuitAccessToken(): Promise<string | null> {
+ 	const cookieStore = cookies();
+ 	return cookieStore.get("intuit_access_token")?.value || null;
+ }
+ 
+ // Create and configure Intuit API client
+ export async function getIntuitClient(): Promise<IntuitClient> {
+ 	const accessToken = await getIntuitAccessToken();
+ 
+ 	if (!accessToken) {
+ 		throw new Error(
+ 			"No Intuit access token found. Please authenticate with Intuit.",
+ 		);
+ 	}
+ 
+ 	const baseURL =
+ 		process.env.INTUIT_API_URL ||
+ 		"https://quickbooks.api.intuit.com/v3/company";
+ 	const realmId = process.env.INTUIT_REALM_ID;
+ 
+ 	if (!realmId) {
+ 		throw new Error("INTUIT_REALM_ID environment variable is required");
+ 	}
+ 
+ 	// Create Axios instance for Intuit API
+ 	const client = axios.create({
+ 		baseURL: `${baseURL}/${realmId}`,
+ 		headers: {
+ 			Authorization: `Bearer ${accessToken}`,
+ 			Accept: "application/json",
+ 			"Content-Type": "application/json",
+ 		},
+ 	});
+ 
+ 	// Add response interceptor to handle errors
+ 	client.interceptors.response.use(
+ 		(response) => response.data,
+ 		async (error) => {
+ 			// Handle authentication errors
+ 			if (error.response && error.response.status === 401) {
+ 				// Could implement token refresh logic here
+ 				console.error("Authentication error with Intuit API");
+ 			}
+ 
+ 			return Promise.reject(error);
+ 		},
+ 	);
+ 
+ 	return client;
+ }
+ 
+ // Export other utility functions as needed
+ 
```

---

Now let's create a simple component to display errors when they occur:

---

```diff
- 
+  
```

---

Let's update our entity detail page to include error handling for API errors:

---

```diff
    EntityType,
  } from '@/services/intuit/types'
+ import {ErrorMessageWithoutRetry} from '@/components/ui/error-message'
  
  // Loading state component
```

```diff
    )
  }
+ 
+ // Error component for showing API errors
+ function EntityDetailError({error, entity}: {error: Error; entity: string}) {
+   return (
+     <Card className='w-full'>
+       <CardHeader>
+         <CardTitle>
+           Error Loading{' '}
+           {entity.charAt(0).toUpperCase() + entity.slice(1).replace(/-/g, ' ')}
+         </CardTitle>
+       </CardHeader>
+       <CardContent>
+         <ErrorMessageWithoutRetry
+           title={`Failed to load ${entity.replace(/-/g, ' ')} details`}
+           message={error.message}
+         />
+       </CardContent>
+     </Card>
+   )
+ }
  
  // Async wrapper for data fetching
```

```diff
    id: string
  }) {
+   try {
      const entityData = await fetchEntityById(entity, id)
  
```

```diff
  
      return <EntityDetailContent entity={entity} data={entityData} />
+   } catch (error) {
+     console.error(`Error fetching ${entity} detail:`, error)
+     return <EntityDetailError error={error as Error} entity={entity} />
+   }
  }
  
```

---

Let's add a simple error message component since the previous edit didn't work correctly:

---

```diff
+ 'use client'
+ 
+ import {AlertCircle, XCircle} from 'lucide-react'
+ import {Button} from '@/components/ui/button'
+ import {useState} from 'react'
+ 
+ interface ErrorMessageProps {
+   title?: string
+   message: string
+   retry?: () => void
+   className?: string
+ }
+ 
+ export function ErrorMessage({
+   title = 'Error',
+   message,
+   retry,
+   className = '',
+ }: ErrorMessageProps) {
+   const [dismissed, setDismissed] = useState(false)
+ 
+   if (dismissed) return null
+ 
+   return (
+     <div className={`rounded-md bg-red-50 p-4 ${className}`}>
+       <div className='flex'>
+         <div className='flex-shrink-0'>
+           <XCircle className='h-5 w-5 text-red-400' aria-hidden='true' />
+         </div>
+         <div className='ml-3'>
+           <h3 className='text-sm font-medium text-red-800'>{title}</h3>
+           <div className='mt-2 text-sm text-red-700'>
+             <p>{message}</p>
+           </div>
+           {retry && (
+             <div className='mt-4'>
+               <div className='-mx-2 -my-1.5 flex'>
+                 <Button
+                   variant='outline'
+                   size='sm'
+                   onClick={retry}
+                   className='bg-red-50 text-red-800 border-red-200 hover:bg-red-100 ml-3'
+                 >
+                   Try again
+                 </Button>
+                 <Button
+                   variant='ghost'
+                   size='sm'
+                   onClick={() => setDismissed(true)}
+                   className='text-red-800 hover:bg-red-100 ml-2'
+                 >
+                   Dismiss
+                 </Button>
+               </div>
+             </div>
+           )}
+         </div>
+       </div>
+     </div>
+   )
+ }
+ 
+ export function ErrorMessageWithoutRetry({
+   title = 'Error',
+   message,
+   className = '',
+ }: Omit<ErrorMessageProps, 'retry'>) {
+   return (
+     <div className={`rounded-md bg-red-50 p-4 ${className}`}>
+       <div className='flex'>
+         <div className='flex-shrink-0'>
+           <AlertCircle className='h-5 w-5 text-red-400' aria-hidden='true' />
+         </div>
+         <div className='ml-3'>
+           <h3 className='text-sm font-medium text-red-800'>{title}</h3>
+           <div className='mt-2 text-sm text-red-700'>
+             <p>{message}</p>
+           </div>
+         </div>
+       </div>
+     </div>
+   )
+ }
+ 
+ // Error boundary fallback component
+ export function ErrorFallback({
+   error,
+   reset,
+ }: {
+   error: Error
+   reset: () => void
+ }) {
+   return (
+     <div className='p-6 max-w-2xl mx-auto my-8'>
+       <ErrorMessage
+         title='Something went wrong'
+         message={error.message}
+         retry={reset}
+         className='mb-4'
+       />
+     </div>
+   )
+ }
  
```

---

Let's create a proper button component for the error message to work:

---

```diff
  'use client'
  
- import {type ButtonHTMLAttributes, forwardRef} from 'react'
+ import * as React from 'react'
+ import {Slot} from '@radix-ui/react-slot'
+ import {cva, type VariantProps} from 'class-variance-authority'
  import {cn} from '@/lib/utils'
  
- export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
-   variant?:
-     | 'default'
-     | 'destructive'
-     | 'outline'
-     | 'secondary'
-     | 'ghost'
-     | 'link'
-   size?: 'default' | 'sm' | 'lg' | 'icon'
- }
- 
- export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
-   ({className, variant = 'default', size = 'default', ...props}, ref) => {
+ const buttonVariants = cva(
+   'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
+   {
+     variants: {
+       variant: {
+         default: 'bg-primary text-primary-foreground hover:bg-primary/90',
+         destructive:
+           'bg-destructive text-destructive-foreground hover:bg-destructive/90',
+         outline:
+           'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
+         secondary:
+           'bg-secondary text-secondary-foreground hover:bg-secondary/80',
+         ghost: 'hover:bg-accent hover:text-accent-foreground',
+         link: 'text-primary underline-offset-4 hover:underline',
+       },
+       size: {
+         default: 'h-10 px-4 py-2',
+         sm: 'h-9 rounded-md px-3',
+         lg: 'h-11 rounded-md px-8',
+         icon: 'h-10 w-10',
+       },
+     },
+     defaultVariants: {
+       variant: 'default',
+       size: 'default',
+     },
+   }
+ )
+ 
+ export interface ButtonProps
+   extends React.ButtonHTMLAttributes<HTMLButtonElement>,
+     VariantProps<typeof buttonVariants> {
+   asChild?: boolean
+ }
+ 
+ const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
+   ({className, variant, size, asChild = false, ...props}, ref) => {
+     const Comp = asChild ? Slot : 'button'
      return (
-       <button
-         className={cn(
-           'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none',
- 
-           // Variants
-           variant === 'default' && 'bg-blue-600 text-white hover:bg-blue-700',
-           variant === 'destructive' && 'bg-red-500 text-white hover:bg-red-600',
-           variant === 'outline' && 'border border-gray-200 hover:bg-gray-100',
-           variant === 'secondary' &&
-             'bg-gray-200 text-gray-900 hover:bg-gray-300',
-           variant === 'ghost' && 'hover:bg-gray-100',
-           variant === 'link' &&
-             'underline-offset-4 hover:underline text-blue-600',
- 
-           // Sizes
-           size === 'default' && 'h-10 py-2 px-4',
-           size === 'sm' && 'h-8 px-3 text-xs',
-           size === 'lg' && 'h-12 px-8 text-base',
-           size === 'icon' && 'h-10 w-10',
- 
-           className
-         )}
+       <Comp
+         className={cn(buttonVariants({variant, size, className}))}
          ref={ref}
          {...props}
```

```diff
    }
  )
- 
  Button.displayName = 'Button'
+ 
+ export {Button, buttonVariants}
  
```

---

Let's create the utils.ts file to support our button component:

---



---

Let's check if the lib folder exists and create it if needed:

---

<details>
            <summary>Listed directory src • **11** results</summary>
        
| Name |
|-------|
| 📄 `middleware.ts` |
| 📁 `services` |
| 📁 `app` |
| 📁 `lib` |
| 📁 `features` |
| 📁 `components` |
| 📄 `constants.ts` |
| 📁 `providers` |
| 📁 `hooks` |
| 📁 `types` |
| 📁 `stories` |

</details>

---



---

_**User**_

Review and merge these into the already existing file. A lot of the api queries you attempted to write already exist in @api.ts and throughout @intuit 

---

_**Assistant**_



---

Looking at your codebase structure, I see that the implementation I proposed overlaps with your existing architecture. Let me adjust our approach to integrate with the existing structure:

1. I'll update the helpers.ts file to use your existing APIs
2. I'll fix the entity detail page to use proper types and the updated helper functions

Here's the integration plan:

---

```diff
  	getProfitAndLossReport,
  } from "@/services/intuit/api";
- import type { EntityType } from "@/services/intuit/types";
+ import type { EntityType, QueryParams } from "@/services/intuit/types";
  import { notFound } from "next/navigation";
  
- export type ApiFunction = (params?: {
- 	limit?: number;
- 	[key: string]: unknown;
- }) => Promise<unknown>;
+ export type ApiFunction = (
+ 	params?: QueryParams,
+ ) => Promise<Record<string, unknown>>;
  
  export const entityApiFunctionMap: Record<EntityType, ApiFunction> = {
```

```diff
  	"profit-and-loss": getProfitAndLossReport,
  };
- 
- // Type for entity detail API functions
- export type GetEntityByIdFunction = (
- 	id: string,
- 	params?: Record<string, unknown>,
- ) => Promise<unknown>;
- 
- // Map entity types to their respective "get by ID" functions
- export const entityDetailApiFunctionMap: Record<
- 	EntityType,
- 	GetEntityByIdFunction
- > = {
- 	accounts: (id, params) => findAccounts({ ...params, id }),
- 	customers: (id, params) => findCustomers({ ...params, id }),
- 	vendors: (id, params) => findVendors({ ...params, id }),
- 	invoices: (id, params) => findInvoices({ ...params, id }),
- 	items: (id, params) => findItems({ ...params, id }),
- 	products: (id, params) => findProducts({ ...params, id }),
- 	purchases: (id, params) => findPurchases({ ...params, id }),
- 	"purchase-orders": (id, params) => findPurchaseOrders({ ...params, id }),
- 	estimates: (id, params) => findEstimates({ ...params, id }),
- 	payments: (id, params) => findPayments({ ...params, id }),
- 	employees: (id, params) => findEmployees({ ...params, id }),
- 	bills: (id, params) => findBills({ ...params, id }),
- 	"account-list-detail": (id, params) =>
- 		getAccountListDetail({ ...params, id }),
- 	"profit-and-loss": (id, params) => getProfitAndLossReport({ ...params, id }),
- };
  
  // Server Component to handle data fetching
```

```diff
  	params?: Record<string, unknown>,
  ) {
- 	if (!entity || !entityDetailApiFunctionMap[entity as EntityType]) {
+ 	if (!entity || !entityApiFunctionMap[entity as EntityType]) {
  		return notFound();
  	}
  
  	try {
- 		// Call the appropriate entity detail API function
- 		const response = await entityDetailApiFunctionMap[entity as EntityType](
+ 		// Use the existing API function with an ID parameter
+ 		const response = await entityApiFunctionMap[entity as EntityType]({
  			id,
- 			params,
- 		);
+ 			...(params || {}),
+ 		});
  
  		// Convert entity string to capitalized singular form for accessing QueryResponse
```

```diff
  
  		// Handle QueryResponse pattern similar to fetchEntityData
- 		if (
- 			response.QueryResponse &&
- 			Object.prototype.hasOwnProperty.call(
- 				response.QueryResponse,
- 				capitalizedEntity,
- 			)
+ 		const queryResponse = response.QueryResponse || response;
+ 
+ 		if (
+ 			queryResponse &&
+ 			Object.prototype.hasOwnProperty.call(queryResponse, capitalizedEntity)
  		) {
  			// For a single entity, we expect an array with one item
- 			const data = response.QueryResponse[capitalizedEntity];
+ 			const data = queryResponse[capitalizedEntity];
  			// If it's an array with one item, return that item
  			if (Array.isArray(data) && data.length === 1) {
```

```diff
  		}
  
- 		// Fallback to the entire QueryResponse or response if specific key not found
- 		return response.QueryResponse || response;
+ 		// Fallback to the entire response if specific key not found
+ 		return queryResponse;
  	} catch (error) {
  		console.error(`Error fetching ${entity} detail for ID ${id}:`, error);
```

---

Now let's update the entity detail page to properly use the existing types:

---

```diff
    PurchaseOrder,
    Account,
-   Estimate,
-   EntityTypeToInterface,
    EntityType,
  } from '@/services/intuit/types'
```

```diff
  }
  
- function EstimateDetail({data}: {data: Estimate}) {
-   return (
-     <>
-       <EntityField label='Estimate Number' value={data.DocNumber} />
-       <EntityField label='Customer' value={data.CustomerRef?.name} />
-       <EntityField label='Total Amount' value={data.TotalAmt} />
-       <EntityField label='Date' value={data.TxnDate} />
-       <EntityField label='Due Date' value={data.DueDate} />
- 
-       {data.Line && data.Line.length > 0 && (
-         <div className='py-2'>
-           <div className='text-sm font-medium text-gray-500 mb-2'>
-             Line Items
-           </div>
-           <div className='mt-1 border rounded-md overflow-hidden'>
-             <table className='min-w-full divide-y divide-gray-200'>
-               <thead className='bg-gray-50'>
-                 <tr>
-                   <th className='px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider'>
-                     Description
-                   </th>
-                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
-                     Qty
-                   </th>
-                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
-                     Price
-                   </th>
-                   <th className='px-4 py-2 text-right text-xs font-medium text-gray-500 uppercase tracking-wider'>
-                     Amount
-                   </th>
-                 </tr>
-               </thead>
-               <tbody className='bg-white divide-y divide-gray-200'>
-                 {data.Line.map((line, index) => (
-                   <tr key={line.Id || index}>
-                     <td className='px-4 py-2 text-sm text-gray-900'>
-                       {line.Description || 'N/A'}
-                     </td>
-                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
-                       {line.SalesItemLineDetail?.Qty || 'N/A'}
-                     </td>
-                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
-                       {line.SalesItemLineDetail?.UnitPrice || 'N/A'}
-                     </td>
-                     <td className='px-4 py-2 text-sm text-gray-900 text-right'>
-                       {line.Amount || 'N/A'}
-                     </td>
-                   </tr>
-                 ))}
-               </tbody>
-             </table>
-           </div>
-         </div>
-       )}
-     </>
-   )
- }
- 
- // Default entity detail component
+ // Default entity detail component for entities without specific components
  function GenericEntityDetail({
    data,
```

```diff
  }: {
    entity: string
-   data: EntityTypeToInterface[keyof EntityTypeToInterface]
+   data: Record<string, unknown>
  }) {
    // Function to get the entity title
```

```diff
      // Try to find a name field based on common patterns
      const nameField =
-       (data as any).DisplayName ||
-       (data as any).Name ||
-       (data as any).DocNumber ||
-       (data as any).Id ||
-       'Details'
+       data.DisplayName || data.Name || data.DocNumber || data.Id || 'Details'
      return `${
        entity.charAt(0).toUpperCase() + entity.slice(1).replace(/-/g, ' ')
```

```diff
        <CardHeader>
          <CardTitle>{getEntityTitle()}</CardTitle>
-         <CardDescription>ID: {(data as any)?.Id || 'N/A'}</CardDescription>
+         <CardDescription>ID: {data?.Id || 'N/A'}</CardDescription>
        </CardHeader>
        <CardContent>
```

```diff
            )}
            {entity === 'accounts' && <AccountDetail data={data as Account} />}
-           {entity === 'estimates' && <EstimateDetail data={data as Estimate} />}
  
            {/* For entities without specific components, use generic renderer */}
```

```diff
              entity !== 'invoices' &&
              entity !== 'purchase-orders' &&
-             entity !== 'accounts' &&
-             entity !== 'estimates' && (
+             entity !== 'accounts' && (
                <GenericEntityDetail
                  data={data as Record<string, unknown>}
```

---

Now I need to fix some of the remaining issues with the types:

---

```diff
  import {cn} from '@/lib/utils'
  
- const buttonVariants = cva(
+ const buttonVariantsStyles = cva(
    'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
    {
```

```diff
  export interface ButtonProps
    extends React.ButtonHTMLAttributes<HTMLButtonElement>,
-     VariantProps<typeof buttonVariants> {
+     VariantProps<typeof buttonVariantsStyles> {
    asChild?: boolean
  }
```

```diff
      return (
        <Comp
-         className={cn(buttonVariants({variant, size, className}))}
+         className={cn(buttonVariantsStyles({variant, size, className}))}
          ref={ref}
          {...props}
```

```diff
  Button.displayName = 'Button'
  
- export {Button, buttonVariants}
+ export {Button, buttonVariantsStyles as buttonVariants}
  
```

---

```diff
- import axios from "axios";
+ import axios, { type AxiosRequestConfig, type AxiosResponse } from "axios";
  import { cookies } from "next/headers";
  
  // Intuit API client interface
  interface IntuitClient {
- 	get: (path: string, config?: any) => Promise<any>;
- 	post: (path: string, data?: any, config?: any) => Promise<any>;
- 	put: (path: string, data?: any, config?: any) => Promise<any>;
- 	delete: (path: string, config?: any) => Promise<any>;
+ 	get: <T = unknown>(path: string, config?: AxiosRequestConfig) => Promise<T>;
+ 	post: <T = unknown>(
+ 		path: string,
+ 		data?: unknown,
+ 		config?: AxiosRequestConfig,
+ 	) => Promise<T>;
+ 	put: <T = unknown>(
+ 		path: string,
+ 		data?: unknown,
+ 		config?: AxiosRequestConfig,
+ 	) => Promise<T>;
+ 	delete: <T = unknown>(
+ 		path: string,
+ 		config?: AxiosRequestConfig,
+ 	) => Promise<T>;
  }
  
```

```diff
  	// Add response interceptor to handle errors
  	client.interceptors.response.use(
- 		(response) => response.data,
+ 		(response: AxiosResponse) => response.data,
  		async (error) => {
  			// Handle authentication errors
```

---

Let's test that our implementation works:

---

```bash
cd /Users/liamellis/Desktop/quickbooks-oracle-initial && npm run lint
```

```
MacBookPro:quickbooks-oracle-initial liamellis$ 

```

---

<details>
            <summary>Listed directory src/services/intuit/types • **2** results</summary>
        
| Name |
|-------|
| 📄 `index.ts` |
| 📄 `response-types.ts` |

</details>

---

Let's verify our implementation works by checking if the types are defined correctly:

---

```diff
  import {Suspense} from 'react'
  import {notFound} from 'next/navigation'
+ import {EntityType} from '@/services/intuit/types'
  import type {
    Customer,
```

```diff
    PurchaseOrder,
    Account,
-   EntityType,
- } from '@/services/intuit/types'
+ } from '@/services/intuit/types/index'
  import {ErrorMessageWithoutRetry} from '@/components/ui/error-message'
  
```

---



---

