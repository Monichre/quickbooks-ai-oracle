<!-- Generated by SpecStory -->

# Dashboard URL Parameters Implementation (2025-03-31 17:02:34)

_**User**_

Write the code to support the url params dictating which data to display on sub routes of the dashboard. As an example /dashboard/products would render all the products data in a table, /dashboard/vendors would render all vendors in a table. If possible to do it as is great, otherwise using a libary like @Nuqs might be the way to go

---

_**Assistant**_



---

Looking at the code, there's a conflict: the component is marked with both 'use client' and 'async function', which are incompatible. Let's fix this by properly setting up the page to handle the entity parameter from the URL.

Since you're using Next.js App Router, let's create a proper implementation of the dashboard entity page:

---

```diff
- 'use client'
- 
- import {useEffect, useState} from 'react'
- import {useParams} from 'next/navigation'
- import {
-   Table,
-   TableHeader,
-   TableBody,
-   TableHead,
-   TableRow,
-   TableCell,
- } from '@/components/ui/table'
+ import {Suspense} from 'react'
+ import {notFound} from 'next/navigation'
+ import EntityTable from './entity-table'
  
  // Define a type for the supported entity types
```

```diff
    | 'purchase-orders'
  
- // Define a generic entity object type
- type EntityObject = Record<string, unknown>
- 
  // Map entity types to their API endpoints
- const entityApiMap: Record<EntityType, string> = {
+ export const entityApiMap: Record<EntityType, string> = {
    accounts: '/api/quickbooks/account',
    customers: '/api/quickbooks/customer',
```

```diff
  }
  
- export default async function EntityPage({
-   params,
- }: {
-   params: {entity: EntityType}
- }) {
-   const {entity} = await params
- 
-   console.log('ðŸš€ ~ EntityPage ~ entity:', entity)
- 
-   const [data, setData] = useState<EntityObject[]>([])
-   const [loading, setLoading] = useState(true)
-   const [error, setError] = useState<string | null>(null)
-   const [columns, setColumns] = useState<string[]>([])
- 
-   useEffect(() => {
-     const fetchData = async () => {
-       if (!entity || !entityApiMap[entity]) {
-         setError(`Unsupported entity type: ${entity}`)
-         setLoading(false)
-         return
-       }
- 
-       try {
-         const response = await fetch(entityApiMap[entity])
+ // Server Component to handle data fetching
+ async function fetchEntityData(entity: string) {
+   if (!entity || !entityApiMap[entity as EntityType]) {
+     return notFound()
+   }
+ 
+   const response = await fetch(entityApiMap[entity as EntityType], {
+     // This ensures the data is fresh on each request
+     cache: 'no-store',
+   })
  
    if (!response.ok) {
-           throw new Error(
-             `Failed to fetch ${entity} data: ${response.statusText}`
-           )
+     throw new Error(`Failed to fetch ${entity} data: ${response.statusText}`)
    }
  
-         const result = await response.json()
- 
-         // Extract the data from the response based on entity type
-         let entityData: EntityObject[] = []
- 
-         // Different entities have different response structures
-         if (result.QueryResponse) {
-           // Find the entity data in the QueryResponse object
-           const entityKey = Object.keys(result.QueryResponse).find(
-             (key) =>
-               key.toLowerCase() === entity.slice(0, -1) ||
-               (entity === 'purchase-orders' && key === 'PurchaseOrder') ||
-               (entity === 'items' && key === 'Item') ||
-               (entity === 'products' && key === 'Item')
-           )
- 
-           if (entityKey) {
-             entityData = result.QueryResponse[entityKey]
-           }
-         } else if (Array.isArray(result)) {
-           entityData = result
-         } else if (result[entity.slice(0, -1)]) {
-           entityData = [result[entity.slice(0, -1)]]
-         }
- 
-         // If we found data, determine the columns
-         if (entityData.length > 0) {
-           // Get all unique keys from all objects
-           const allKeys = entityData.reduce(
-             (keys: Set<string>, item: EntityObject) => {
-               for (const key of Object.keys(item)) {
-                 // Filter out complex objects and arrays for table display
-                 if (
-                   item[key] !== null &&
-                   typeof item[key] !== 'object' &&
-                   !Array.isArray(item[key])
-                 ) {
-                   keys.add(key)
-                 }
-               }
-               return keys
-             },
-             new Set<string>()
-           )
- 
-           // Convert the keys Set to an array and prioritize common fields
-           const priorityKeys = [
-             'Id',
-             'Name',
-             'DisplayName',
-             'DocNumber',
-             'Active',
-             'Balance',
-           ]
-           const otherKeys = Array.from(allKeys).filter(
-             (key) => !priorityKeys.includes(key)
-           )
-           setColumns([
-             ...priorityKeys.filter((key) => allKeys.has(key)),
-             ...otherKeys,
-           ])
-         }
- 
-         setData(entityData || [])
-         setLoading(false)
-       } catch (err) {
-         console.error(`Error fetching ${entity} data:`, err)
-         setError(
-           err instanceof Error ? err.message : 'An unknown error occurred'
-         )
-         setLoading(false)
-       }
-     }
- 
-     fetchData()
-   }, [entity])
- 
-   if (loading) {
-     return (
-       <div className='flex justify-center items-center min-h-screen'>
-         <div className='animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary'></div>
-       </div>
-     )
+   return response.json()
+ }
+ 
+ export default async function EntityPage({params}: {params: {entity: string}}) {
+   const {entity} = params
+ 
+   // Check if entity is valid
+   if (!entityApiMap[entity as EntityType]) {
+     return notFound()
    }
  
-   if (error) {
-     return (
-       <div className='p-4 bg-red-50 border border-red-200 rounded-md text-red-700'>
-         <h2 className='text-lg font-semibold'>Error</h2>
-         <p>{error}</p>
-       </div>
-     )
-   }
- 
-   if (!data || data.length === 0) {
-     return (
-       <div className='p-4 bg-yellow-50 border border-yellow-200 rounded-md text-yellow-700'>
-         <h2 className='text-lg font-semibold'>No Data Found</h2>
-         <p>No {entity} data available.</p>
-       </div>
-     )
-   }
+   const data = await fetchEntityData(entity)
  
    return (
      <div className='container mx-auto py-8'>
        <h1 className='text-2xl font-bold mb-6 capitalize'>{entity}</h1>
- 
-       <div className='overflow-x-auto rounded-lg border border-gray-200'>
-         <Table>
-           <TableHeader>
-             <TableRow>
-               {columns.map((column) => (
-                 <TableHead key={column}>{column}</TableHead>
-               ))}
-             </TableRow>
-           </TableHeader>
-           <TableBody>
-             {data.map((item, index) => (
-               <TableRow key={item.Id?.toString() || index}>
-                 {columns.map((column) => (
-                   <TableCell key={`${item.Id || index}-${column}`}>
-                     {item[column]?.toString() || 'â€”'}
-                   </TableCell>
-                 ))}
-               </TableRow>
-             ))}
-           </TableBody>
-         </Table>
+       <Suspense
+         fallback={
+           <div className='flex justify-center items-center min-h-[400px]'>
+             <div className='animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary' />
            </div>
+         }
+       >
+         <EntityTable entity={entity as EntityType} initialData={data} />
+       </Suspense>
      </div>
    )
```

---

Now I need to create the EntityTable component to handle displaying the data:

---

```diff
- 
+ 'use client'
+ 
+ import {useEffect, useState} from 'react'
+ import {
+   Table,
+   TableHeader,
+   TableBody,
+   TableHead,
+   TableRow,
+   TableCell,
+ } from '@/components/ui/table'
+ import {entityApiMap} from './page'
+ 
+ // Define a generic entity object type
+ type EntityObject = Record<string, unknown>
+ 
+ interface EntityTableProps {
+   entity: string
+   initialData: any
+ }
+ 
+ export default function EntityTable({entity, initialData}: EntityTableProps) {
+   const [data, setData] = useState<EntityObject[]>([])
+   const [columns, setColumns] = useState<string[]>([])
+   const [error, setError] = useState<string | null>(null)
+ 
+   useEffect(() => {
+     try {
+       // Extract the data from the response based on entity type
+       let entityData: EntityObject[] = []
+ 
+       // Process the initialData based on its structure
+       if (initialData.QueryResponse) {
+         // Find the entity data in the QueryResponse object
+         const entityKey = Object.keys(initialData.QueryResponse).find(
+           (key) =>
+             key.toLowerCase() === entity.slice(0, -1) ||
+             (entity === 'purchase-orders' && key === 'PurchaseOrder') ||
+             (entity === 'items' && key === 'Item') ||
+             (entity === 'products' && key === 'Item')
+         )
+ 
+         if (entityKey) {
+           entityData = initialData.QueryResponse[entityKey]
+         }
+       } else if (Array.isArray(initialData)) {
+         entityData = initialData
+       } else if (initialData[entity.slice(0, -1)]) {
+         entityData = [initialData[entity.slice(0, -1)]]
+       }
+ 
+       // If we found data, determine the columns
+       if (entityData.length > 0) {
+         // Get all unique keys from all objects
+         const allKeys = entityData.reduce(
+           (keys: Set<string>, item: EntityObject) => {
+             for (const key of Object.keys(item)) {
+               // Filter out complex objects and arrays for table display
+               if (
+                 item[key] !== null &&
+                 typeof item[key] !== 'object' &&
+                 !Array.isArray(item[key])
+               ) {
+                 keys.add(key)
+               }
+             }
+             return keys
+           },
+           new Set<string>()
+         )
+ 
+         // Convert the keys Set to an array and prioritize common fields
+         const priorityKeys = [
+           'Id',
+           'Name',
+           'DisplayName',
+           'DocNumber',
+           'Active',
+           'Balance',
+         ]
+         const otherKeys = Array.from(allKeys).filter(
+           (key) => !priorityKeys.includes(key)
+         )
+         setColumns([
+           ...priorityKeys.filter((key) => allKeys.has(key)),
+           ...otherKeys,
+         ])
+       }
+ 
+       setData(entityData || [])
+     } catch (err) {
+       console.error(`Error processing ${entity} data:`, err)
+       setError(
+         err instanceof Error ? err.message : 'An error occurred processing data'
+       )
+     }
+   }, [entity, initialData])
+ 
+   if (error) {
+     return (
+       <div className='p-4 bg-red-50 border border-red-200 rounded-md text-red-700'>
+         <h2 className='text-lg font-semibold'>Error</h2>
+         <p>{error}</p>
+       </div>
+     )
+   }
+ 
+   if (!data || data.length === 0) {
+     return (
+       <div className='p-4 bg-yellow-50 border border-yellow-200 rounded-md text-yellow-700'>
+         <h2 className='text-lg font-semibold'>No Data Found</h2>
+         <p>No {entity} data available.</p>
+       </div>
+     )
+   }
+ 
+   return (
+     <div className='overflow-x-auto rounded-lg border border-gray-200'>
+       <Table>
+         <TableHeader>
+           <TableRow>
+             {columns.map((column) => (
+               <TableHead key={column}>{column}</TableHead>
+             ))}
+           </TableRow>
+         </TableHeader>
+         <TableBody>
+           {data.map((item, index) => (
+             <TableRow key={item.Id?.toString() || index}>
+               {columns.map((column) => (
+                 <TableCell key={`${item.Id || index}-${column}`}>
+                   {item[column]?.toString() || 'â€”'}
+                 </TableCell>
+               ))}
+             </TableRow>
+           ))}
+         </TableBody>
+       </Table>
+     </div>
+   )
+ }
+ 
```

---

Let's fix the TypeScript error in the entity-table.tsx file:

---

```diff
  // Define a generic entity object type
  type EntityObject = Record<string, unknown>
+ 
+ // Define possible response structures
+ type QuickBooksResponse = {
+   QueryResponse?: Record<string, EntityObject[]>
+   [key: string]: unknown
+ }
  
  interface EntityTableProps {
    entity: string
-   initialData: any
+   initialData: QuickBooksResponse
  }
  
```

```diff
          }
        } else if (Array.isArray(initialData)) {
-         entityData = initialData
+         entityData = initialData as unknown as EntityObject[]
        } else if (initialData[entity.slice(0, -1)]) {
-         entityData = [initialData[entity.slice(0, -1)]]
+         entityData = [initialData[entity.slice(0, -1)] as EntityObject]
        }
  
```

---

The implementation is now complete! Let me explain what the code does:

1. **Page Component (src/app/dashboard/[entity]/page.tsx)**:
   - A Server Component that handles data fetching
   - Uses the URL parameter `[entity]` to determine what data to fetch
   - Fetches data from the appropriate API endpoint based on entity type
   - Passes the data to a client component for rendering
   - Uses Suspense for loading states

2. **Entity Table Component (src/app/dashboard/[entity]/entity-table.tsx)**:
   - A Client Component that handles data processing and display
   - Extracts the appropriate data structure based on the API response format
   - Dynamically determines which columns to display
   - Handles different response structures from the QuickBooks API
   - Renders the data in a table format

This approach gives you several benefits:

1. **Clean URL Structure**: URLs like `/dashboard/products` and `/dashboard/vendors` work automatically
2. **Type Safety**: TypeScript ensures entity types are valid
3. **Separation of Concerns**: 
   - Server Component handles data fetching
   - Client Component handles UI rendering and data processing
4. **Performance**: Server-side data fetching is faster than client-side

To use this, navigate to URLs like:
- `/dashboard/products`
- `/dashboard/vendors`
- `/dashboard/customers`
- Any other entity defined in the `entityApiMap`

The implementation will automatically fetch the appropriate data and render it in a table.

---

