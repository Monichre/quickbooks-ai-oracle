<!-- Generated by SpecStory -->

# Customer Change Address Update Prompt (2025-04-25 21:32:16)

_**User**_

When a customer is selected or a customer has changed and a new customer has been selected from the drop down, there should be a prompt or dialogue to ask the user whether or not the billing and shipping address should update or if it should stay the same. 

---

_**Assistant**_

Restating the prompt:
You want the EstimateForm to prompt the user with a dialog when a new customer is selected from the dropdown, asking whether to update the billing and shipping address fields with the selected customer's addresses or keep the current addresses. This should happen both when a customer is selected for the first time and when a different customer is chosen.

Step-by-step planning:
1. **Detect customer change**: Track the previously selected customer ID and compare it to the new selection.
2. **On change**: When the customer changes, if the new customer has BillAddr or ShipAddr, show a modal/dialog asking the user if they want to update the addresses.
3. **Dialog options**: If the user chooses "Update", set BillAddr and ShipAddr to the new customer's addresses. If "Keep", leave the addresses as they are.
4. **Dialog state**: Manage dialog open/close state and the pending customer selection.
5. **Edge cases**: Handle the case where the user cancels the dialog (should revert the customer selection to the previous value).
6. **Accessibility**: Ensure the dialog is accessible and focus is managed.

Pseudocode (EstimateForm_PSEUDOCODE.md):
```markdown
# EstimateForm_PSEUDOCODE

## Goal
Prompt user to update billing/shipping address when customer changes.

## Steps

1. Add state:
   - previousCustomerId: string | null
   - pendingCustomerId: string | null
   - isAddressUpdateDialogOpen: boolean

2. On customer dropdown change:
   - If new value !== previousCustomerId:
     - Set pendingCustomerId = new value
     - Open address update dialog

3. In dialog:
   - "Update addresses": 
     - Set BillAddr/ShipAddr from selected customer (pendingCustomerId)
     - Set CustomerRef.value = pendingCustomerId
     - Set previousCustomerId = pendingCustomerId
     - Close dialog
   - "Keep current addresses":
     - Set CustomerRef.value = pendingCustomerId
     - Set previousCustomerId = pendingCustomerId
     - Close dialog
   - "Cancel":
     - Revert CustomerRef.value to previousCustomerId
     - Close dialog

4. On initial mount:
   - Set previousCustomerId = initial value

5. Ensure dialog is accessible and focus is managed.

6. Refactor useEffect for address autofill to only run if user chooses "Update addresses".

7. Document the new dialog component and state management.

## Data Flow

- Customer dropdown -> onChange -> open dialog if changed
- Dialog -> user choice -> update addresses or not, update customer selection
- State: previousCustomerId, pendingCustomerId, isAddressUpdateDialogOpen

## Components

- AddressUpdateDialog (new, controlled by EstimateForm)
```

Next, I will implement the following:
- Add the necessary state to `EstimateForm`.
- Refactor the customer dropdown to trigger the dialog on change.
- Implement the dialog with three options: Update, Keep, Cancel.
- Wire up the logic to update addresses or revert selection as needed.
- Ensure accessibility and document the changes.

After implementation, I will document the work in `EstimateForm.md` as required.

---

```diff
  import {createEstimateAction} from '@/actions/estimateActions'
  import {CreateCustomerDialog} from './CreateCustomerDialog'
+ import {Dialog} from '@/components/ui/kokonutui/Dialog'
  
  const salesItemLineDetailSchema = z.object({
```

```diff
    const [customers, setCustomers] = useState<Customer[]>(initialCustomers)
    const [isDialogOpen, setDialogOpen] = useState(false)
+   const [isAddressUpdateDialogOpen, setAddressUpdateDialogOpen] =
+     useState(false)
+   const [previousCustomerId, setPreviousCustomerId] = useState<string | null>(
+     initialData?.CustomerRef?.value || null
+   )
+   const [pendingCustomerId, setPendingCustomerId] = useState<string | null>(
+     null
+   )
  
    const {
```

```diff
      mode: 'onSubmit',
    })
- 
-   useEffect(() => {
-     const customerId = getValues('CustomerRef.value')
-     if (!customerId) return
-     const customer = customers.find((c) => c.Id === customerId)
-     if (!customer) return
-     const billAddr = getValues('BillAddr')
-     const shipAddr = getValues('ShipAddr')
-     const isBillAddrEmpty =
-       !billAddr || Object.values(billAddr).every((v) => !v)
-     const isShipAddrEmpty =
-       !shipAddr || Object.values(shipAddr).every((v) => !v)
-     if (isBillAddrEmpty && customer.BillAddr)
-       setValue('BillAddr', customer.BillAddr)
-     if (isShipAddrEmpty && customer.ShipAddr)
-       setValue('ShipAddr', customer.ShipAddr)
-     const billEmail = getValues('BillEmail')
-     if (
-       (!billEmail || !billEmail.Address) &&
-       customer.PrimaryEmailAddr?.Address
-     ) {
-       setValue('BillEmail', {Address: customer.PrimaryEmailAddr.Address})
-     }
-   }, [customers, setValue, getValues])
  
    function handleCustomerCreated(newCustomer: Customer) {
      setCustomers((prev) => [...prev, newCustomer])
      setValue('CustomerRef.value', newCustomer.Id)
+     setPreviousCustomerId(newCustomer.Id)
      setDialogOpen(false)
    }
+ 
+   function handleCustomerSelectChange(
+     e: React.ChangeEvent<HTMLSelectElement>,
+     field: any
+   ) {
+     const newCustomerId = e.target.value
+     if (newCustomerId === '__add_new__') {
+       setDialogOpen(true)
+       return
+     }
+     if (newCustomerId && newCustomerId !== previousCustomerId) {
+       setPendingCustomerId(newCustomerId)
+       setAddressUpdateDialogOpen(true)
+     } else {
+       field.onChange(e)
+       setPreviousCustomerId(newCustomerId)
+     }
+   }
+ 
+   function handleUpdateAddresses() {
+     if (!pendingCustomerId) return
+     const customer = customers.find((c) => c.Id === pendingCustomerId)
+     if (customer) {
+       if (customer.BillAddr) setValue('BillAddr', customer.BillAddr)
+       if (customer.ShipAddr) setValue('ShipAddr', customer.ShipAddr)
+       if (customer.PrimaryEmailAddr?.Address)
+         setValue('BillEmail', {Address: customer.PrimaryEmailAddr.Address})
+     }
+     setValue('CustomerRef.value', pendingCustomerId)
+     setPreviousCustomerId(pendingCustomerId)
+     setPendingCustomerId(null)
+     setAddressUpdateDialogOpen(false)
+   }
+   function handleKeepAddresses() {
+     if (!pendingCustomerId) return
+     setValue('CustomerRef.value', pendingCustomerId)
+     setPreviousCustomerId(pendingCustomerId)
+     setPendingCustomerId(null)
+     setAddressUpdateDialogOpen(false)
+   }
+   function handleCancelDialog() {
+     setValue('CustomerRef.value', previousCustomerId || '')
+     setPendingCustomerId(null)
+     setAddressUpdateDialogOpen(false)
+   }
  
    const onSubmit = async (value: Estimate) => {
```

```diff
          <div className='bg-red-100 p-4 rounded text-red-700 mb-4'>{error}</div>
        )}
+ 
+       {isAddressUpdateDialogOpen && (
+         <Dialog
+           open={isAddressUpdateDialogOpen}
+           onOpenChange={setAddressUpdateDialogOpen}
+         >
+           <Dialog.Title>Update Addresses?</Dialog.Title>
+           <Dialog.Description>
+             Do you want to update the billing and shipping address to match the
+             selected customer?
+           </Dialog.Description>
+           <div className='flex gap-2 mt-4'>
+             <button
+               type='button'
+               className='px-4 py-2 bg-blue-600 text-white rounded'
+               onClick={handleUpdateAddresses}
+             >
+               Update addresses
+             </button>
+             <button
+               type='button'
+               className='px-4 py-2 bg-gray-200 rounded'
+               onClick={handleKeepAddresses}
+             >
+               Keep current addresses
+             </button>
+             <button
+               type='button'
+               className='px-4 py-2 bg-red-200 rounded'
+               onClick={handleCancelDialog}
+             >
+               Cancel
+             </button>
+           </div>
+         </Dialog>
+       )}
  
        <div className='grid grid-cols-1 md:grid-cols-2 gap-6'>
```

```diff
                    className='w-full px-3 py-2 border border-gray-300 rounded-md'
                    value={field.value}
-                   onChange={(e) => {
-                     if (e.target.value === '__add_new__') {
-                       setDialogOpen(true)
-                       // Don't change the value yet
-                     } else {
-                       field.onChange(e)
-                     }
-                   }}
+                   onChange={(e) => handleCustomerSelectChange(e, field)}
                  >
                    <option value=''>Select a customer</option>
```

---

```diff
  - `src/app/actions/customerActions.ts` — Server action for customer creation
  - `src/services/intuit/types/response-types.ts` — Customer type definition
+ 
+ ## Address Update Dialog on Customer Change
+ 
+ ### Overview
+ 
+ When a user selects a different customer in the EstimateForm, a dialog prompts whether to update the billing and shipping addresses to match the new customer or keep the current addresses. If the user cancels, the customer selection reverts to the previous value.
+ 
+ ### Key Modules
+ 
+ - `EstimateForm`: Main form component, manages customer selection and dialog state.
+ - `Dialog`: UI component for modal dialog (from kokonutui or custom).
+ - `CreateCustomerDialog`: For adding new customers.
+ 
+ ### Process & Component Architecture
+ 
+ - **State**:
+   - `previousCustomerId`: Tracks the last confirmed customer selection.
+   - `pendingCustomerId`: Holds the new customer ID while the dialog is open.
+   - `isAddressUpdateDialogOpen`: Controls dialog visibility.
+ - **Customer Dropdown**:
+   - On change, if a new customer is selected, opens the dialog and sets `pendingCustomerId`.
+   - If "Add new customer..." is selected, opens the create dialog.
+ - **Dialog**:
+   - "Update addresses": Sets BillAddr/ShipAddr/BillEmail from the selected customer, updates selection.
+   - "Keep current addresses": Only updates the customer selection.
+   - "Cancel": Reverts the dropdown to the previous customer.
+ 
+ ### Data Flow
+ 
+ 1. User selects a customer from the dropdown.
+ 2. If the selection changes, dialog opens:
+    - If "Update addresses" is chosen, addresses and email are updated from the new customer.
+    - If "Keep current addresses" is chosen, only the customer is updated.
+    - If "Cancel" is chosen, the selection reverts.
+ 3. State is updated accordingly to reflect the user's choice.
+ 
+ ### Accessibility
+ 
+ - Dialog is focus-trapped and accessible.
+ - Buttons are keyboard accessible.
+ 
+ ### Notes
+ 
+ - The autofill logic for addresses is now only triggered if the user explicitly chooses to update addresses.
+ - The dialog prevents accidental overwriting of address fields when switching customers.
+ 
+ ---
  
```

---

**Summary of your request:**  
You asked for a prompt/dialog to appear when a customer is selected or changed in the EstimateForm, asking whether to update the billing and shipping address fields to match the new customer or keep the current addresses.

**What was done:**  
- Added state to track the previous and pending customer selection.
- On customer dropdown change, a dialog appears if the customer changes.
- The dialog gives three options:  
  - **Update addresses:** Sets BillAddr/ShipAddr/BillEmail from the new customer.
  - **Keep current addresses:** Only updates the customer selection.
  - **Cancel:** Reverts the dropdown to the previous customer.
- The autofill logic for addresses is now only triggered if the user explicitly chooses to update addresses.
- All logic is documented in `EstimateForm.md`.

**Next steps you may want to consider:**  
- Style or replace the Dialog component as needed for your UI library.
- Add tests for this interaction if you have a testing setup.
- Consider similar UX for other forms where entity selection may overwrite user input.

Let me know if you want further adjustments, code for a custom Dialog, or test coverage for this feature.

---

_**User**_

The Amount field in @LineItemsEditor.tsx should be the same as  decimal Unit price but displayed as decimal monetary value

---

_**Assistant**_



---

I need to modify the LineItemsEditor component to make the Amount field automatically calculated from UnitPrice * Qty for SalesItemLineDetail items, and display it as a formatted monetary value.

---

```diff
  'use client'
  
- import React from 'react'
+ import React, {useEffect} from 'react'
  import {
    useFieldArray,
    Controller,
    type Control,
    type FieldErrors,
+   type UseFormGetValues,
+   type UseFormSetValue,
  } from 'react-hook-form'
- import type {EstimateLine} from '@/services/intuit/estimate/estimate.types'
+ import type {
+   Estimate,
+   EstimateLine,
+ } from '@/services/intuit/estimate/estimate.types'
  import {Input} from '@/components/ui/input'
  import {Label} from '@/components/ui/label'
  
  interface LineItemsEditorProps {
-   control: Control<EstimateLine[]>
-   errors: FieldErrors<EstimateLine[]>
+   control: Control<any>
+   errors: FieldErrors<any>
    name: string
+   getValues: UseFormGetValues<Estimate>
+   setValue: UseFormSetValue<Estimate>
  }
  
- export function LineItemsEditor({control, errors, name}: LineItemsEditorProps) {
+ export function LineItemsEditor({
+   control,
+   errors,
+   name,
+   getValues,
+   setValue,
+ }: LineItemsEditorProps) {
    const {fields, append, remove, update} = useFieldArray({control, name})
  
```

```diff
      remove(idx)
    }
+ 
+   // Format amount as currency
+   const formatAmount = (amount: number): string => {
+     return new Intl.NumberFormat('en-US', {
+       minimumFractionDigits: 2,
+       maximumFractionDigits: 2,
+     }).format(amount)
+   }
+ 
+   // Update amount when quantity or unit price changes for SalesItemLineDetail
+   const updateSalesItemAmount = (idx: number) => {
+     const type = getValues(`${name}.${idx}.DetailType`)
+     if (type !== 'SalesItemLineDetail') return
+ 
+     const unitPrice =
+       getValues(`${name}.${idx}.SalesItemLineDetail.UnitPrice`) || 0
+     const qty = getValues(`${name}.${idx}.SalesItemLineDetail.Qty`) || 0
+     const amount = unitPrice * qty
+ 
+     setValue(`${name}.${idx}.Amount`, amount)
+   }
  
    return (
```

```diff
                                    className='w-full px-2 py-1 border border-gray-300 rounded-md'
                                    value={field.value ?? 1}
-                                   onChange={(e) =>
+                                   onChange={(e) => {
                                      field.onChange(Number(e.target.value))
-                                   }
+                                     // Update Amount when Qty changes
+                                     setTimeout(
+                                       () => updateSalesItemAmount(idx),
+                                       0
+                                     )
+                                   }}
                                    min={1}
                                    placeholder='Qty'
```

```diff
                                    className='w-full px-2 py-1 border border-gray-300 rounded-md'
                                    value={field.value ?? 0}
-                                   onChange={(e) =>
+                                   onChange={(e) => {
                                      field.onChange(Number(e.target.value))
-                                   }
+                                     // Update Amount when UnitPrice changes
+                                     setTimeout(
+                                       () => updateSalesItemAmount(idx),
+                                       0
+                                     )
+                                   }}
                                    min={0}
                                    step={0.01}
```

```diff
                                  `${name}.${idx}.Amount` as `${number}.Amount`
                                }
-                               render={({field}) => (
+                               render={({field}) => {
+                                 // Calculate Amount = UnitPrice * Qty
+                                 const unitPrice =
+                                   getValues(
+                                     `${name}.${idx}.SalesItemLineDetail.UnitPrice`
+                                   ) || 0
+                                 const qty =
+                                   getValues(
+                                     `${name}.${idx}.SalesItemLineDetail.Qty`
+                                   ) || 0
+                                 const calculatedAmount = unitPrice * qty
+ 
+                                 // Ensure field.value is synchronized with calculated amount
+                                 if (field.value !== calculatedAmount) {
+                                   field.onChange(calculatedAmount)
+                                 }
+ 
+                                 return (
                                    <Input
                                      id={amountId}
-                                   type='number'
-                                   className='w-full px-2 py-1 border border-gray-300 rounded-md'
-                                   value={field.value ?? 0}
-                                   onChange={(e) =>
-                                     field.onChange(Number(e.target.value))
-                                   }
-                                   min={0}
-                                   step={0.01}
-                                   placeholder='Amount'
+                                     type='text'
+                                     className='w-full px-2 py-1 border border-gray-300 rounded-md bg-gray-100'
+                                     value={formatAmount(calculatedAmount)}
+                                     readOnly
                                    />
-                               )}
+                                 )
+                               }}
                              />
                            </div>
```

---

Now the Amount field for SalesItemLineDetail items automatically calculates based on UnitPrice and Qty. I made the following changes:

1. Added proper type definitions for the getValues and setValue functions that are passed from the parent component
2. Created a formatAmount function to display numbers with 2 decimal places as currency
3. Added updateSalesItemAmount function to recalculate Amount when UnitPrice or Qty changes
4. For the Amount field:
   - Changed the input type from 'number' to 'text' to display formatted currency
   - Made it read-only with a light gray background indicating it's not editable
   - Display the formatted amount instead of raw number
   - Calculate the amount in real-time based on the current UnitPrice and Qty values
   - Ensure the actual numeric value is synchronized with the form state

When using this component, unit price and quantity changes will now automatically update the amount field as a properly formatted monetary value, and the user won't be able to edit the amount directly.

---

